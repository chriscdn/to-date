{"version":3,"file":"to-date.modern.js","sources":["../src/index.ts"],"sourcesContent":["const isLikelyMilliseconds = (n: number) => Math.log10(n) >= 10;\nconst isLikelyMicroseconds = (n: number) => Math.log10(n) >= 13;\n\nconst isDate = (object: unknown): object is Date =>\n  object instanceof Date && !isNaN(object.getTime());\n\nenum EpochUnit {\n  BESTGUESS,\n  SECONDS,\n  MILLISCONDS,\n  MICROSECONDS,\n}\n\ntype TValue = Date | string | number | null | undefined;\n\n// We're guaranteed a Date return value if the input is a number or Date.\ntype TReturnValue<T> = T extends Date | number ? Date : Date | undefined;\n\nconst toDate = <T extends TValue>(\n  value: T,\n  epochUnit = EpochUnit.BESTGUESS,\n): TReturnValue<T> => {\n  if (isDate(value)) {\n    return value;\n  } else if (typeof value === \"string\") {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#date_time_string_format\n    const _d = new Date(value);\n    return (isDate(_d) ? _d : undefined) as TReturnValue<T>;\n  } else if (typeof value === \"number\") {\n    let baseValue!: number;\n\n    // assert value > 0 ?\n\n    switch (epochUnit) {\n      case EpochUnit.BESTGUESS:\n        baseValue = isLikelyMicroseconds(value)\n          ? value / 1000\n          : isLikelyMilliseconds(value)\n          ? value\n          : value * 1000;\n        break;\n      case EpochUnit.SECONDS:\n        baseValue = value * 1000;\n        break;\n      case EpochUnit.MILLISCONDS:\n        baseValue = value;\n        break;\n      case EpochUnit.MICROSECONDS:\n        baseValue = value / 1000;\n        break;\n    }\n\n    return new Date(baseValue);\n  } else {\n    return undefined as TReturnValue<T>;\n  }\n};\n\n/**\n * This method handles a specific parsing scenario when string dates are given\n * without a time zone, e.g., 2025-02-07T15:00:00.\n *\n * When passed to `new Date()`, the date is assumed to be in the local device's\n * time zone. As a result, devices in different time zones will interpret the\n * value differently.\n *\n * This isn't always a problem. For example, the `Intl.DateTimeFormat` date\n * formatter will format the value in the local time zone.\n *\n * Things get difficult when parsing a value and formatting in a differnt time\n * zone.\n *\n */\nconst toDateUTC = (value: string): TReturnValue<string> => {\n  const theDate = toDate(value);\n\n  if (isDate(theDate)) {\n    return toDate(\n      Date.UTC(\n        theDate.getFullYear(),\n        theDate.getMonth(),\n        theDate.getDate(),\n        theDate.getHours(),\n        theDate.getMinutes(),\n        theDate.getSeconds(),\n      ),\n    );\n  } else {\n    return null;\n  }\n};\n\nexport { EpochUnit, isDate, toDate, toDateUTC };\n"],"names":["isDate","object","Date","isNaN","getTime","EpochUnit","toDate","value","epochUnit","BESTGUESS","_d","undefined","baseValue","Math","log10","SECONDS","MILLISCONDS","MICROSECONDS","toDateUTC","theDate","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds"],"mappings":"AAAA,MAGMA,EAAUC,GACdA,aAAkBC,OAASC,MAAMF,EAAOG,WAErC,IAAAC,GAAL,SAAKA,GACHA,EAAAA,EAAA,UAAA,GAAA,YACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,aAAA,GAAA,cACD,CALD,CAAKA,IAAAA,EAKJ,CAAA,IAOK,MAAAC,EAASA,CACbC,EACAC,EAAYH,EAAUI,aAEtB,GAAIT,EAAOO,GACT,OAAOA,EACE,GAAiB,iBAAVA,EAAoB,CAEpC,MAAMG,EAAK,IAAIR,KAAKK,GACpB,OAAQP,EAAOU,GAAMA,OAAKC,CAC3B,IAA2B,iBAAVJ,EAAoB,CACpC,IAAIK,EAIJ,OAAQJ,GACN,KAAKH,EAAUI,UACbG,EAlCoCC,KAAKC,MAkCRP,IAlCoB,GAmCjDA,EAAQ,IApCwBM,KAAKC,MAqChBP,IArC4B,GAsCjDA,EACQ,IAARA,EACJ,MACF,KAAKF,EAAUU,QACbH,EAAoB,IAARL,EACZ,MACF,KAAKF,EAAUW,YACbJ,EAAYL,EACZ,MACF,KAAKF,EAAUY,aACbL,EAAYL,EAAQ,IAIxB,OAAO,IAAIL,KAAKU,EACjB,CAEA,EAkBGM,EAAaX,IACjB,MAAMY,EAAUb,EAAOC,GAEvB,OAAIP,EAAOmB,GACFb,EACLJ,KAAKkB,IACHD,EAAQE,cACRF,EAAQG,WACRH,EAAQI,UACRJ,EAAQK,WACRL,EAAQM,aACRN,EAAQO,eAIL,IACR"}