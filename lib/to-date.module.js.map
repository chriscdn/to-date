{"version":3,"file":"to-date.module.js","sources":["../src/index.ts"],"sourcesContent":["const isLikelyMilliseconds = (n: number) => Math.log10(n) >= 10;\nconst isLikelyMicroseconds = (n: number) => Math.log10(n) >= 13;\n\nconst isDate = (item: unknown): item is Date =>\n  item instanceof Date && !isNaN(item.getTime());\n\nenum EpochUnit {\n  BESTGUESS,\n  SECONDS,\n  MILLISCONDS,\n  MICROSECONDS,\n}\n\ntype TValue = Date | string | number | null | undefined;\n\n// We're guaranteed a Date return value if the input is a number or Date.\ntype TReturnValue<T> = T extends Date | number ? Date : Date | null;\n\nconst toDate = <T extends TValue>(\n  value: T,\n  epochUnit = EpochUnit.BESTGUESS,\n): TReturnValue<T> => {\n  if (isDate(value)) {\n    return new Date(value.getTime());\n  } else if (typeof value === \"string\") {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#date_time_string_format\n    const _d = new Date(value);\n    return (isDate(_d) ? _d : undefined) as TReturnValue<T>;\n  } else if (typeof value === \"number\") {\n    let baseValue!: number;\n\n    switch (epochUnit) {\n      case EpochUnit.BESTGUESS:\n        baseValue = isLikelyMicroseconds(value)\n          ? value / 1000\n          : isLikelyMilliseconds(value)\n          ? value\n          : value * 1000;\n        break;\n      case EpochUnit.SECONDS:\n        baseValue = value * 1000;\n        break;\n      case EpochUnit.MILLISCONDS:\n        baseValue = value;\n        break;\n      case EpochUnit.MICROSECONDS:\n        baseValue = value / 1000;\n        break;\n    }\n\n    return new Date(baseValue);\n  } else {\n    return null as TReturnValue<T>;\n  }\n};\n\n/**\n * This method handles a specific parsing scenario when string dates are given\n * without a time zone, e.g., \"2025-02-07T15:00:00\".\n *\n * When passed to `new Date()`, such dates are interpreted as local time based\n * on the device's time zone. As a result, the same value may be interpreted\n * differently on devices in different time zones.\n *\n * This behavior is usually acceptable when the date is processed and displayed\n * on the same client. For example, `Intl.DateTimeFormat` will correctly format\n * the date in the local time zone.\n *\n * However, issues arise when environments in different time zones are involved.\n * For instance, a server (e.g., during server-side rendering) located in a\n * different time zone than the client may interpret and serialize the date\n * incorrectly, leading to inconsistencies.\n */\nconst toDateUTC = <T extends TValue>(value: T): TReturnValue<T> => {\n  const theDate = toDate(value);\n\n  if (isDate(theDate)) {\n    return toDate(\n      Date.UTC(\n        theDate.getFullYear(),\n        theDate.getMonth(),\n        theDate.getDate(),\n        theDate.getHours(),\n        theDate.getMinutes(),\n        theDate.getSeconds(),\n      ),\n    );\n  } else {\n    return null as TReturnValue<T>;\n  }\n};\n\nconst _getTimeZoneOffset = (\n  date: Date,\n  timeZone: Intl.DateTimeFormatOptions[\"timeZone\"],\n) => {\n  const formatter = new Intl.DateTimeFormat(\"en-US\", {\n    timeZone: timeZone,\n    timeZoneName: \"shortOffset\",\n  });\n\n  const parts = formatter.formatToParts(date);\n\n  const timeZoneName = parts?.find(\n    (part) => part.type === \"timeZoneName\",\n  )?.value;\n\n  if (timeZoneName === \"GMT\") {\n    return 0;\n  } else {\n    const offsetMatch = timeZoneName?.match(/GMT([+-]\\d+)/);\n\n    if (offsetMatch) {\n      const offsetHours = parseInt(offsetMatch[1], 10);\n      return offsetHours * 60; // Convert hours to minutes\n    } else {\n      throw new Error(`Unable to determine offset for time zone: ${timeZone}`);\n    }\n  }\n};\n\n/**\n * Similar to `toDateUTC`, this method handles a specific parsing scenario when\n * string dates are provided without a time zone, e.g., \"2025-02-07T15:00:00\".\n *\n * This function differs from `toDate` by accepting a second parameter for the\n * time zone (e.g., \"America/Toronto\") and converting the date-time accordingly\n * to that time zone.\n *\n * Example: toDateInTimeZone('2025-06-27T14:00:00', 'America/Toronto')\n *\n * Interprets \"2025-06-27 14:00:00\" as occurring in the \"America/Toronto\" time\n *  zone.\n *\n * This is useful for handling local date-times in a specific time zone without\n * assuming UTC.\n */\nconst toDateInTimeZone = <T extends TValue>(\n  value: T,\n  timeZone: Intl.DateTimeFormatOptions[\"timeZone\"],\n): TReturnValue<T> => {\n  const theDate = toDateUTC(value);\n\n  if (isDate(theDate)) {\n    const timeZoneOffset = _getTimeZoneOffset(theDate, timeZone);\n\n    /// theDate is a clone of value, so we can mutate it.\n    theDate.setMinutes(theDate.getMinutes() - timeZoneOffset);\n\n    return theDate;\n  } else {\n    return null as TReturnValue<T>;\n  }\n};\n\nexport { EpochUnit, isDate, toDate, toDateUTC, toDateInTimeZone };\n"],"names":["EpochUnit","isDate","item","Date","isNaN","getTime","toDate","value","epochUnit","BESTGUESS","_d","undefined","baseValue","Math","log10","SECONDS","MILLISCONDS","MICROSECONDS","toDateUTC","theDate","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","toDateInTimeZone","timeZone","timeZoneOffset","date","_parts$find","parts","Intl","DateTimeFormat","timeZoneName","formatToParts","find","part","type","offsetMatch","match","parseInt","Error","_getTimeZoneOffset","setMinutes"],"mappings":"AAAA,IAMKA,EAHCC,EAAS,SAACC,GACd,OAAAA,aAAgBC,OAASC,MAAMF,EAAKG,UAAU,GAEhD,SAAKL,GACHA,EAAAA,EAAA,UAAA,GAAA,YACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,aAAA,GAAA,cACD,CALD,CAAKA,IAAAA,EAKJ,CAAA,IAOK,IAAAM,EAAS,SACbC,EACAC,GAEA,QAFAA,IAAAA,IAAAA,EAAYR,EAAUS,WAElBR,EAAOM,GACT,WAAWJ,KAAKI,EAAMF,WACb,GAAiB,iBAAVE,EAAoB,CAEpC,IAAMG,EAAK,IAAIP,KAAKI,GACpB,OAAQN,EAAOS,GAAMA,OAAKC,CAC3B,CAAM,GAAqB,iBAAVJ,EAAoB,CACpC,IAAIK,EAEJ,OAAQJ,GACN,KAAKR,EAAUS,UACbG,EAhCoCC,KAAKC,MAgCRP,IAhCoB,GAiCjDA,EAAQ,IAlCwBM,KAAKC,MAmChBP,IAnC4B,GAoCjDA,EACQ,IAARA,EACJ,MACF,KAAKP,EAAUe,QACbH,EAAoB,IAARL,EACZ,MACF,KAAKP,EAAUgB,YACbJ,EAAYL,EACZ,MACF,KAAKP,EAAUiB,aACbL,EAAYL,EAAQ,IAIxB,WAAWJ,KAAKS,EACjB,CACC,OACD,IACH,EAmBMM,EAAY,SAAmBX,GACnC,IAAMY,EAAUb,EAAOC,GAEvB,OAAIN,EAAOkB,GACFb,EACLH,KAAKiB,IACHD,EAAQE,cACRF,EAAQG,WACRH,EAAQI,UACRJ,EAAQK,WACRL,EAAQM,aACRN,EAAQO,eAIL,IAEX,EA+CMC,EAAmB,SACvBpB,EACAqB,GAEA,IAAMT,EAAUD,EAAUX,GAE1B,GAAIN,EAAOkB,GAAU,CACnB,IAAMU,EApDiB,SACzBC,EACAF,OACEG,EAMIC,EALY,IAAIC,KAAKC,eAAe,QAAS,CACjDN,SAAUA,EACVO,aAAc,gBAGQC,cAAcN,GAEhCK,EAAoB,MAALH,GAEpB,OAFyBD,EAALC,EAAOK,KAC1B,SAACC,GAAS,MAAc,iBAAdA,EAAKC,IAAuB,SACvC,EAFoBR,EAElBxB,MAEH,GAAqB,QAAjB4B,EACF,OACD,EACC,IAAMK,QAAcL,SAAAA,EAAcM,MAAM,gBAExC,GAAID,EAEF,OAAqB,GADDE,SAASF,EAAY,GAAI,IAG7C,MAAU,IAAAG,MAAmDf,6CAAAA,EAGnE,CAyB2BgB,CAAmBzB,EAASS,GAKnD,OAFAT,EAAQ0B,WAAW1B,EAAQM,aAAeI,GAEnCV,CACR,CACC,OACD,IACH"}