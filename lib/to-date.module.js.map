{"version":3,"file":"to-date.module.js","sources":["../src/index.ts"],"sourcesContent":["const isLikelyMilliseconds = (n: number) => Math.log10(n) >= 10;\nconst isLikelyMicroseconds = (n: number) => Math.log10(n) >= 13;\n\nconst isDate = (item: unknown): item is Date =>\n  item instanceof Date && !isNaN(item.getTime());\n\nenum EpochUnit {\n  BESTGUESS,\n  SECONDS,\n  MILLISCONDS,\n  MICROSECONDS,\n}\n\ntype TValue = Date | string | number | null | undefined;\n\n// We're guaranteed a Date return value if the input is a number or Date.\ntype TReturnValue<T> = T extends Date | number ? Date : Date | null;\n\nconst toDate = <T extends TValue>(\n  value: T,\n  epochUnit = EpochUnit.BESTGUESS,\n): TReturnValue<T> => {\n  if (isDate(value)) {\n    return new Date(value.getTime());\n  } else if (typeof value === \"string\") {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#date_time_string_format\n    const _d = new Date(value);\n    return (isDate(_d) ? _d : undefined) as TReturnValue<T>;\n  } else if (typeof value === \"number\") {\n    let baseValue!: number;\n\n    switch (epochUnit) {\n      case EpochUnit.BESTGUESS:\n        baseValue = isLikelyMicroseconds(value)\n          ? value / 1000\n          : isLikelyMilliseconds(value)\n          ? value\n          : value * 1000;\n        break;\n      case EpochUnit.SECONDS:\n        baseValue = value * 1000;\n        break;\n      case EpochUnit.MILLISCONDS:\n        baseValue = value;\n        break;\n      case EpochUnit.MICROSECONDS:\n        baseValue = value / 1000;\n        break;\n    }\n\n    return new Date(baseValue);\n  } else {\n    return null as TReturnValue<T>;\n  }\n};\n\nconst isISO8601WithoutTimeZone = (str: unknown) => {\n  if (typeof str === \"string\") {\n    const regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}$/;\n    return regex.test(str);\n  } else {\n    return false;\n  }\n};\n\n/**\n * This method handles a specific parsing scenario when string dates are given\n * without a time zone, e.g., \"2025-02-07T15:00:00\".\n *\n * When passed to `new Date()`, such dates are interpreted as local time based\n * on the device's time zone. As a result, the same value may be interpreted\n * differently on devices in different time zones.\n *\n * This behavior is usually acceptable when the date is processed and displayed\n * on the same client. For example, `Intl.DateTimeFormat` will correctly format\n * the date in the local time zone.\n *\n * However, issues arise when environments in different time zones are involved.\n * For instance, a server (e.g., during server-side rendering) located in a\n * different time zone than the client may interpret and serialize the date\n * incorrectly, leading to inconsistencies.\n */\nconst toDateUTC = <T extends TValue>(value: T): TReturnValue<T> => {\n  const theDate = toDate(value);\n\n  if (isDate(theDate)) {\n    // Dates such as \"2025-01-01\" are interpretted in UTC. So are dates with a\n    // time zone specififer e.g., \"2025-01-01T15:00:00Z\" or\n    // \"2007-04-05T12:30âˆ’02:00\".\n    //\n    // For this reason we explicitly check if the dates is iso8601 without a\n    // time zone.\n\n    if (isISO8601WithoutTimeZone(value)) {\n      return toDate(\n        Date.UTC(\n          theDate.getFullYear(),\n          theDate.getMonth(),\n          theDate.getDate(),\n          theDate.getHours(),\n          theDate.getMinutes(),\n          theDate.getSeconds(),\n        ),\n      );\n    } else {\n      return theDate;\n    }\n  } else {\n    return null as TReturnValue<T>;\n  }\n};\n\nconst getTimeZoneOffsetHours = (\n  date: Date,\n  timeZone: Intl.DateTimeFormatOptions[\"timeZone\"],\n) => {\n  const formatter = new Intl.DateTimeFormat(\"en-US\", {\n    timeZone: timeZone,\n    timeZoneName: \"shortOffset\",\n  });\n\n  const parts = formatter.formatToParts(date);\n\n  const timeZoneName = parts?.find(\n    (part) => part.type === \"timeZoneName\",\n  )?.value;\n\n  if (timeZoneName === \"GMT\") {\n    return 0;\n  } else {\n    const offsetMatch = timeZoneName?.match(/GMT([+-]\\d+)/);\n\n    if (offsetMatch) {\n      const offsetHours = parseInt(offsetMatch[1], 10);\n      // return offsetHours * 60; // Convert hours to minutes\n      return offsetHours;\n    } else {\n      throw new Error(`Unable to determine offset for time zone: ${timeZone}`);\n    }\n  }\n};\n\n/**\n * Similar to `toDateUTC`, this method handles a specific parsing scenario when\n * string dates are provided without a time zone, e.g., \"2025-02-07T15:00:00\".\n *\n * This function differs from `toDate` by accepting a second parameter for the\n * time zone (e.g., \"America/Toronto\") and converting the date-time accordingly\n * to that time zone.\n *\n * Example: toDateInTimeZone('2025-06-27T14:00:00', 'America/Toronto')\n *\n * Interprets \"2025-06-27 14:00:00\" as occurring in the \"America/Toronto\" time\n * zone.\n *\n * This is useful for handling local date-times in a specific time zone without\n * assuming UTC.\n */\nconst toDateInTimeZone = <T extends TValue>(\n  value: T,\n  timeZone: Intl.DateTimeFormatOptions[\"timeZone\"],\n): TReturnValue<T> => {\n  const theDate = toDateUTC(value);\n\n  if (isDate(theDate)) {\n    if (isISO8601WithoutTimeZone(value)) {\n      const timeZoneOffsetHours = getTimeZoneOffsetHours(theDate, timeZone);\n\n      /// theDate is a clone of value, so we can mutate it.\n      theDate.setHours(theDate.getHours() - timeZoneOffsetHours);\n    }\n\n    return theDate;\n  } else {\n    return null as TReturnValue<T>;\n  }\n};\n\nexport {\n  EpochUnit,\n  isDate,\n  toDate,\n  toDateUTC,\n  toDateInTimeZone,\n  getTimeZoneOffsetHours,\n};\n"],"names":["EpochUnit","isDate","item","Date","isNaN","getTime","toDate","value","epochUnit","BESTGUESS","_d","undefined","baseValue","Math","log10","SECONDS","MILLISCONDS","MICROSECONDS","isISO8601WithoutTimeZone","str","test","toDateUTC","theDate","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getTimeZoneOffsetHours","date","timeZone","_parts$find","parts","Intl","DateTimeFormat","timeZoneName","formatToParts","find","part","type","offsetMatch","match","parseInt","Error","toDateInTimeZone","timeZoneOffsetHours","setHours"],"mappings":"AAAA,IAMKA,EAHCC,EAAS,SAACC,GAAa,OAC3BA,aAAgBC,OAASC,MAAMF,EAAKG,UAAU,GAEhD,SAAKL,GACHA,EAAAA,EAAA,UAAA,GAAA,YACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,aAAA,GAAA,cACD,CALD,CAAKA,IAAAA,EAKJ,CAAA,IAOK,IAAAM,EAAS,SACbC,EACAC,GAEA,QAFAA,IAAAA,IAAAA,EAAYR,EAAUS,WAElBR,EAAOM,GACT,OAAO,IAAIJ,KAAKI,EAAMF,WACjB,GAAqB,iBAAVE,EAAoB,CAEpC,IAAMG,EAAK,IAAIP,KAAKI,GACpB,OAAQN,EAAOS,GAAMA,OAAKC,CAC3B,CAAM,GAAqB,iBAAVJ,EAAoB,CACpC,IAAIK,EAEJ,OAAQJ,GACN,KAAKR,EAAUS,UACbG,EAhCoCC,KAAKC,MAgCRP,IAhCoB,GAiCjDA,EAAQ,IAlCwBM,KAAKC,MAmChBP,IAnC4B,GAoCjDA,EACQ,IAARA,EACJ,MACF,KAAKP,EAAUe,QACbH,EAAoB,IAARL,EACZ,MACF,KAAKP,EAAUgB,YACbJ,EAAYL,EACZ,MACF,KAAKP,EAAUiB,aACbL,EAAYL,EAAQ,IAIxB,WAAWJ,KAAKS,EACjB,CACC,WAEJ,EAEMM,EAA2B,SAACC,GAChC,MAAmB,iBAARA,GACK,wCACDC,KAAKD,EAItB,EAmBME,EAAY,SAAmBd,GACnC,IAAMe,EAAUhB,EAAOC,GAEvB,OAAIN,EAAOqB,GAQLJ,EAAyBX,GACpBD,EACLH,KAAKoB,IACHD,EAAQE,cACRF,EAAQG,WACRH,EAAQI,UACRJ,EAAQK,WACRL,EAAQM,aACRN,EAAQO,eAILP,EAGF,IAEX,EAEMQ,EAAyB,SAC7BC,EACAC,GACE,IAAAC,EAMIC,EALY,IAAIC,KAAKC,eAAe,QAAS,CACjDJ,SAAUA,EACVK,aAAc,gBAGQC,cAAcP,GAEhCM,EAAoBJ,MAALC,UAAKD,EAALC,EAAOK,KAC1B,SAACC,GAAI,MAAmB,iBAAdA,EAAKC,IAAuB,WADnBR,EAElB1B,MAEH,GAAqB,QAAjB8B,EACF,OAAO,EAEP,IAAMK,QAAcL,SAAAA,EAAcM,MAAM,gBAExC,GAAID,EAGF,OAFoBE,SAASF,EAAY,GAAI,IAI7C,MAAU,IAAAG,MAAmDb,6CAAAA,EAGnE,EAkBMc,EAAmB,SACvBvC,EACAyB,GAEA,IAAMV,EAAUD,EAAUd,GAE1B,GAAIN,EAAOqB,GAAU,CACnB,GAAIJ,EAAyBX,GAAQ,CACnC,IAAMwC,EAAsBjB,EAAuBR,EAASU,GAG5DV,EAAQ0B,SAAS1B,EAAQK,WAAaoB,EACvC,CAED,OAAOzB,CACR,CACC,OAAO,IAEX"}